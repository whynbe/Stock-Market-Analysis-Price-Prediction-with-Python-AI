import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib

matplotlib.use('TkAgg')
import matplotlib.pyplot as plt
from sklearn.preprocessing import StandardScaler
from sklearn.neural_network import MLPRegressor
import ssl
import certifi

# Fix SSL issues
ssl._create_default_https_context = ssl._create_unverified_context
import os

os.environ['REQUESTS_CA_BUNDLE'] = certifi.where()

print("D√©marrage du programme d'analyse financi√®re...")


# -----------------------------
# 1Ô∏è‚É£ CR√âATION DE DONN√âES R√âALISTES (AM√âLIOR√âE)
# -----------------------------
def create_realistic_sample_data():
    """Cr√©e des donn√©es boursi√®res r√©alistes avec tendances et volatilit√© diff√©rentes"""
    dates = pd.date_range(start="2023-01-01", end="2024-01-01", freq='D')
    np.random.seed(42)

    # Tendances diff√©rentes pour chaque action
    trends = {
        'AAPL': 0.0005,  # L√©g√®re tendance haussi√®re
        'MSFT': 0.0003,  # Tendence mod√©r√©e
        'GOOGL': 0.0001,  # Tendence faible
        'TSLA': 0.0010,  # Forte volatilit√©
        'AMZN': 0.0004  # Tendence stable
    }

    volatilities = {
        'AAPL': 0.02,
        'MSFT': 0.015,
        'GOOGL': 0.012,
        'TSLA': 0.04,
        'AMZN': 0.018
    }

    data = {}
    prices_init = {'AAPL': 150, 'MSFT': 300, 'GOOGL': 2500, 'TSLA': 200, 'AMZN': 130}

    for ticker in ['AAPL', 'MSFT', 'GOOGL']:  # On garde 3 actions pour la d√©mo
        # G√©n√©ration de prix plus r√©aliste avec tendance + bruit
        returns = np.random.normal(trends[ticker], volatilities[ticker], len(dates))
        prices = prices_init[ticker] * np.exp(np.cumsum(returns))
        data[ticker] = prices

    return pd.DataFrame(data, index=dates)


# Utiliser les donn√©es de d√©monstration r√©alistes
print("Cr√©ation de donn√©es boursi√®res r√©alistes...")
data = create_realistic_sample_data()
tickers = data.columns.tolist()

print("Donn√©es cr√©√©es :")
print(data.head())
print(f"\nP√©riode: {data.index[0].date()} to {data.index[-1].date()}")
print(f"Nombre de jours: {len(data)}")

# -----------------------------
# 2Ô∏è‚É£ ANALYSE STATISTIQUE (CORRIG√âE)
# -----------------------------
returns = data.pct_change().dropna()

mean_returns = returns.mean()
volatility = returns.std()
correlation = returns.corr()

print("\n" + "=" * 50)
print("ANALYSE STATISTIQUE R√âALISTE")
print("=" * 50)

print("\nüìà Rendements moyens quotidiens:")
for ticker in tickers:
    print(f"  {ticker}: {mean_returns[ticker]:.4%}")

print("\nüìä Volatilit√© quotidienne:")
for ticker in tickers:
    print(f"  {ticker}: {volatility[ticker]:.4%}")

print("\nüîÑ Matrice de corr√©lation:")
print(correlation.round(3))

# -----------------------------
# 3Ô∏è‚É£ VISUALISATION AM√âLIOR√âE
# -----------------------------
plt.style.use('seaborn-v0_8')
fig, axes = plt.subplots(2, 2, figsize=(15, 10))

# Graphique 1: Prix historiques
axes[0, 0].set_title('√âvolution des Prix', fontweight='bold')
for ticker in tickers:
    axes[0, 0].plot(data.index, data[ticker], label=ticker, linewidth=2)
axes[0, 0].set_ylabel('Prix ($)')
axes[0, 0].legend()
axes[0, 0].grid(True, alpha=0.3)

# Graphique 2: Rendements cumul√©s
cumulative_returns = (1 + returns).cumprod()
axes[0, 1].set_title('Rendements Cumul√©s', fontweight='bold')
for ticker in tickers:
    axes[0, 1].plot(cumulative_returns.index, cumulative_returns[ticker], label=ticker, linewidth=2)
axes[0, 1].set_ylabel('Rendement Cumul√© (1 = 100%)')
axes[0, 1].legend()
axes[0, 1].grid(True, alpha=0.3)

# Graphique 3: Matrice de corr√©lation
im = axes[1, 0].imshow(correlation, cmap='RdYlBu', aspect='auto', vmin=-1, vmax=1)
axes[1, 0].set_title('Matrice de Corr√©lation', fontweight='bold')
plt.colorbar(im, ax=axes[1, 0])
axes[1, 0].set_xticks(range(len(tickers)))
axes[1, 0].set_yticks(range(len(tickers)))
axes[1, 0].set_xticklabels(tickers)
axes[1, 0].set_yticklabels(tickers)

# Graphique 4: Volatilit√©
axes[1, 1].bar(tickers, volatility.values, color=['#1f77b4', '#ff7f0e', '#2ca02c'])
axes[1, 1].set_title('Volatilit√© des Actions', fontweight='bold')
axes[1, 1].set_ylabel('Volatilit√© Quotidienne')
axes[1, 1].tick_params(axis='x', rotation=45)

plt.tight_layout()
plt.show()


# -----------------------------
# 4Ô∏è‚É£ OPTIMISATION DU PORTEFEUILLE (AM√âLIOR√âE)
# -----------------------------
def optimize_portfolio(returns, num_portfolios=15000):
    """Optimisation robuste du portefeuille"""
    results = np.zeros((4, num_portfolios))  # +1 pour les poids
    weights_record = []

    mean_returns_annual = returns.mean() * 252
    cov_matrix_annual = returns.cov() * 252

    for i in range(num_portfolios):
        weights = np.random.dirichlet(np.ones(len(tickers)))  # Meilleure distribution
        port_return = np.dot(weights, mean_returns_annual)
        port_volatility = np.sqrt(np.dot(weights.T, np.dot(cov_matrix_annual, weights)))
        sharpe_ratio = port_return / port_volatility if port_volatility > 0 else 0

        results[0, i] = port_return
        results[1, i] = port_volatility
        results[2, i] = sharpe_ratio
        weights_record.append(weights)

    # Meilleur portefeuille par ratio de Sharpe
    max_sharpe_idx = np.argmax(results[2])
    optimal_weights = weights_record[max_sharpe_idx]

    return optimal_weights, results[:, max_sharpe_idx]


print("\n" + "=" * 50)
print("OPTIMISATION DU PORTEFEUILLE")
print("=" * 50)

optimal_weights, optimal_results = optimize_portfolio(returns)

print("\nüéØ PORTEFEUILLE OPTIMAL (Max Ratio de Sharpe):")
print("-" * 45)
total_weight = 0
for ticker, weight in zip(tickers, optimal_weights):
    if weight > 0.01:  # Afficher seulement les poids significatifs
        print(f"  {ticker}: {weight:.2%}")
        total_weight += weight

print(f"  Total: {total_weight:.2%}")

print(f"\nüìä Performance annuelle attendue:")
print(f"  ‚ñ∏ Rendement: {optimal_results[0]:.2%}")
print(f"  ‚ñ∏ Volatilit√©: {optimal_results[1]:.2%}")
print(f"  ‚ñ∏ Ratio de Sharpe: {optimal_results[2]:.2f}")

# -----------------------------
# 5Ô∏è‚É£ PR√âDICTIONS IA (CORRIG√âE)
# -----------------------------
print("\n" + "=" * 50)
print("PR√âDICTIONS INTELLIGENCE ARTIFICIELLE")
print("=" * 50)

future_days = 30
predictions_dict = {}

print("Entra√Ænement des mod√®les de pr√©diction...")

for ticker in tickers:
    try:
        # Pr√©parer les donn√©es
        X = np.arange(len(data)).reshape(-1, 1)
        y = data[ticker].values

        # Normalisation
        scaler_X = StandardScaler()
        scaler_y = StandardScaler()
        X_scaled = scaler_X.fit_transform(X)
        y_scaled = scaler_y.fit_transform(y.reshape(-1, 1)).ravel()

        # Mod√®le plus robuste
        model = MLPRegressor(
            hidden_layer_sizes=(100, 50, 25),
            max_iter=3000,
            random_state=42,
            alpha=0.001,
            learning_rate_init=0.001
        )

        model.fit(X_scaled, y_scaled)

        # Pr√©dictions
        future_X = np.arange(len(data), len(data) + future_days).reshape(-1, 1)
        future_X_scaled = scaler_X.transform(future_X)
        pred_scaled = model.predict(future_X_scaled)
        predictions = scaler_y.inverse_transform(pred_scaled.reshape(-1, 1)).flatten()

        predictions_dict[ticker] = predictions
        last_prediction = predictions[-1]  # ‚úÖ CORRECTION ICI

        print(f"‚úÖ {ticker}: Pr√©diction √† 30j = ${last_prediction:.2f}")

    except Exception as e:
        print(f"‚ùå {ticker}: Erreur - {str(e)[:100]}...")
        # Valeur par d√©faut r√©aliste
        predictions_dict[ticker] = np.full(future_days, data[ticker].iloc[-1])

# -----------------------------
# 6Ô∏è‚É£ VISUALISATION DES PR√âDICTIONS
# -----------------------------
print("\nüîÑ G√©n√©ration des graphiques de pr√©diction...")

plt.figure(figsize=(15, 10))
for i, ticker in enumerate(tickers, 1):
    plt.subplot(2, 2, i)

    # Derniers 60 jours historiques
    historical_data = data[ticker].iloc[-60:]
    plt.plot(historical_data.index, historical_data.values, 'b-',
             label='Historique', linewidth=2, alpha=0.8)

    # Pr√©dictions
    future_dates = pd.date_range(start=data.index[-1], periods=future_days + 1, freq='D')[1:]
    plt.plot(future_dates, predictions_dict[ticker], 'r--',
             label='Pr√©diction (30j)', linewidth=2)

    # Connexion
    plt.plot([data.index[-1], future_dates[0]],
             [data[ticker].iloc[-1], predictions_dict[ticker][0]],
             'r--', alpha=0.5)

    plt.title(f'{ticker} - Pr√©vision des Prix', fontweight='bold')
    plt.xlabel('Date')
    plt.ylabel('Prix ($)')
    plt.legend()
    plt.grid(True, alpha=0.3)

    # Infobox
    current_price = data[ticker].iloc[-1]
    predicted_price = predictions_dict[ticker][-1]
    change_pct = ((predicted_price - current_price) / current_price) * 100

    bbox_props = dict(boxstyle="round,pad=0.3", facecolor="lightyellow", alpha=0.8)
    plt.text(0.02, 0.98,
             f'Prix actuel: ${current_price:.2f}\n'
             f'Pr√©vision: ${predicted_price:.2f}\n'
             f'Variation: {change_pct:+.1f}%',
             transform=plt.gca().transAxes, verticalalignment='top',
             bbox=bbox_props, fontsize=9)

plt.tight_layout()
plt.show()

# -----------------------------
# 7Ô∏è‚É£ RAPPORT FINAL D√âTAILL√â
# -----------------------------
print("\n" + "=" * 60)
print("üìä RAPPORT FINAL D'ANALYSE FINANCI√àRE")
print("=" * 60)

print(f"\nüìà PERFORMANCE SUR LA P√âRIODE ({len(data)} jours):")
print("-" * 55)

for ticker in tickers:
    initial_price = data[ticker].iloc[0]
    final_price = data[ticker].iloc[-1]
    total_return = ((final_price / initial_price) - 1) * 100
    predicted_price = predictions_dict[ticker][-1]
    future_return = ((predicted_price / final_price) - 1) * 100

    print(f"\n{ticker}:")
    print(f"  ‚ñ∏ Prix initial: ${initial_price:.2f}")
    print(f"  ‚ñ∏ Prix final: ${final_price:.2f}")
    print(f"  ‚ñ∏ Rendement p√©riode: {total_return:+.2f}%")
    print(f"  ‚ñ∏ Pr√©vision 30j: ${predicted_price:.2f}")
    print(f"  ‚ñ∏ Variation attendue: {future_return:+.2f}%")
    print(f"  ‚ñ∏ Volatilit√©: {volatility[ticker]:.4f}")

print(f"\nüí° ANALYSE DU PORTEFEUILLE OPTIMAL:")
print("-" * 55)
print("R√©partition recommand√©e:")
for ticker, weight in zip(tickers, optimal_weights):
    if weight > 0.05:
        amount = weight * 10000  # Pour un portefeuille de $10,000
        print(f"  ‚ñ∏ {ticker}: {weight:.1%} (${amount:.0f})")

print(f"\nüìã CARACT√âRISTIQUES ATTENDUES:")
print(f"  ‚ñ∏ Rendement annuel: {optimal_results[0]:.1%}")
print(f"  ‚ñ∏ Volatilit√© annuelle: {optimal_results[1]:.1%}")
print(f"  ‚ñ∏ Ratio de Sharpe: {optimal_results[2]:.2f}")

print("\n" + "=" * 60)
print("üéâ ANALYSE TERMIN√âE AVEC SUCC√àS!")
print("=" * 60)